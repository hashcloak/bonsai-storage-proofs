# Obtain fresh testdata for testing

There are 2 tests in `tests/StorageProofChecker.t.sol` using different testdata. This file describes how that type of test data can be obtained. 

## Retrieve data

To verify a storage proof you need the following elements:
- key
- proof elements (variable size)
- root (storageHash)
And the value that you are verifying.

The complete storageproof can be obtained with getProof using for example web3js. For full details about the response see [EIP-1186](https://eips.ethereum.org/EIPS/eip-1186).

Code snippets to use:

For example, using an API key from alchemy, instantiate web3 like this:
```
const web3 = new Web3(`https://opt-goerli.g.alchemy.com/v2/<API_KEY>`);
```

To get a storageProof you need to pass in a contractAddress, the storage indices (keys) that you want to retrieve and optionally the blocknumber. Adding the blocknumber makes sure you always get the same response. 
```
    let contractAddress = '0x92ba07eFCd0D0258eD492F0e13fdAc0145495229'
    const storageProof = await web3.eth.getProof(contractAddress, ['0x0000000000000000000000000000000000000000000000000000000000000000', '0x0000000000000000000000000000000000000000000000000000000000000001'], 15584190);
```

From the response we need 2 parts:
- storageHash
- one of the elements in storageProof

This is an example response:
```
{
  accountProof: [
    '0xf90211a0d3cf236d1414ac3a48ea2df5580f1ca6d87865b42274048f69fb5518bc973e10a0ffd8aa4ee9842175b112205443f8f1f540fb02c0ba3543c08c53632544c23f82a07b4562749594855528dde538837ee3a8eac1285193a8c8d74fd8b27095239cc3a0ee1ec3db70165ebe87d7de10ff5581037dd1ffa2e5567b8b10573441c9a3f4aca002895141a262b1c8cd7800963f179db8d675874e091fea5fa5756630cb1bae18a0599c6d937e643b07204cdf75e8fcbbcb34ecf5d88c77410689f701acb57554cea05cd4af24319e2e0c644fbb5882afb0710415e6aef184ba765e66aeffdafbbfaea0d3dd2af3818cb7d224623c6b13338e2dd78d1105882d7975f0743b1d711c59eca0731f98c8d6007879a8a4fb39636f8ecfe4cb6d7d9bfb5c4ef03c94629d53649fa0754bc3da640ef31c58c5ec959ddff38c1bd9ee743bd8456e7fe9e553889183e4a0fbe3b0aa545b34cf0a4f36502c857883fff83900bfbc62b6b629228b1f66395aa07f26e272e3a5c56aaff9da6653df0b0494abb8338c5549bc8c27ce0e4f28977ea0d718bfaa365f18f61cb73dbc2421d1cc2dbe44f430d373238314cfbb9fcca7d3a0ac49b15ebaf721cab0a74524f9954df53ecb741a6833c2af9314a10c10bde065a0d7c94ce4d4cfe857dbf737211d3047b56e1f56251574d12bf18652149b09720ba0216340933f3b5b79b3c07919bc3b3317f07c85c638ce89019795a4174c9fda9880',
    '0xf90211a0e4f82206e3c5ed5986dd2af4b8bbb58e97d602d24a22682502af42a39a33b330a0813fdc73e45b056e931d7ef49a3ada4b13397a6a2ea500cb23943e9429788b11a03a1ccdc0b99ed5c3624d6afcc182ecda4578b667003b881f2dd907f9614798fca0ce35f12435d337d16a62683efe8e135c0e7e795bfb14def2ef501d64efd482f6a0a3848a460b2e07b6248252ca42fb001e4695bc13975642c00602332322368b0ea089ae6e0a96d80b14aa64d3b157f07ddd86c9058ab2bc9294cfb959d3811d0d79a08ada09e9dc343e29236ddcb019072f91a14c2118559b07bf60ec317ecd36bfc2a09dc28291fe361756a2104a00c85a1bd6bde838221a77d20dc390fd6563aae85fa03c014f5780a15128a129625ec53f3c89df806d72df5f730f9e217046f28c8a97a040ea8f8a79ce3869a8ff0d555bc859b8167a4cb900031fa2d350e1f0356ed70fa060875d84d641dfe498b31b63bec8d5ca6283d07b239f194f32b51917ff741d99a0494ec5f80ea9900921fe408852c42bc9253df0b0e97904dc9c0dbcfc26409282a0eaa355dce4b17ede418c3a8e2c234caaada172557f5e3a9940b43f0207d03804a0c4d3eb33672ddf0a80c8f6abb81a40194b166a5df8b87699a02a7786dc8ad44ba0ab7c9faf11a052ae721dca7d5f88a63053bf53d02600321f0ada22d28c0f9a6ba053d180fa1b41ec1c1a035a1c763323a3a307e2a93a4c75c2275d8f2d5d7a61ae80',
    '0xf90211a061d41c75f23ca7f41213158001b275e29dbb0f44ea39876c781a539800b54566a0042c355e50e1a36ae10324ada34e9585175a5c5f023e416f554ed17af06dbe6ea0cb5928afd0ca737a2689d6dd2ac663c2b981c20817149e7ee2d1ed6cfc8352b7a03eb68461ecd2c085de35a39cb83f1484c1b79a6701c412fe847ea1b37706cf6da019a19c77eec4478c818b38acdd35bdc423c92519f7986d5037015f0f1f428deaa041fd7f74164fd66b9503565eb6112d76e00212dfb409df3a181ed3eb7ad366d3a038422a0419f918387628619b1278dd469f9dd76058609fd3e2c10f660f76edb1a063e8fd66028c05879768003dcbaaca504392e8e96090d1f44adcc92a46c3489da08321de7bb6f7086d380ff30135d6f968cb9c6df7eff4ffea9f6d86d45b7cfd4fa00ba87ae63fb8b0ea2888150b2611afff50ea77feceed9a9362fa0ace50e86b31a00987b0dc9e20236852134f8e0070f62f1dcb9a584bc8ca8c1570e22f574b8493a038c3b2ec1f0f8030d69290bb6d20c6929b268d4f7f1191ad9abce7f05aed0983a0af554148b8bcf7119c30d5dac9f28b599685c6b8c6027540f5a551b1efcee246a0f3b3636cad1b8d94473771f892b28ccfe739546dba2df905ede9585a9976bdd8a08ccf035db3943a3b3ec8ff5e744c58cd18c2eb99bc2499ef7ba9f695b6bc8454a0c0cf7244f97fb8e9ae7f33739835781dbf9f3ac55340d1496c211073b114adfc80',
    '0xf90211a0eb6cb9ec0024831a1ac319bf805db7b9af0b4c3fcaaf25675407416f081669b3a02627e0e0286b27073eea0fa198363392e2286be78ad1f5c1c2165ac89870da6da067d4218e3cfef5da3bc81f23956aca05bf0bb1273dbeb487b14f5536fec257f2a0a982aefbc8e55cf0ffed1a67038075bd77a00c73f1a34bc8d2bf30a5463e833ea0cca8d4da343f169a234c7d75ea667f922f4a30006a108b84cd3c2d4a01cd42c7a04c4be37a66e0603ad9ad2b00d71149b7e7edb6abda433621fa4dfb0d8b5b21c6a01f258f911950d356a2d8c361d3cf82bb4f39cb833cef1d8fb8922d9c09f398a3a05d6594a2626681f77bad458c42c670e78b19dc43402ca8c9598c87833360cd7ba0fd0ca18bb9736cfde73a9e09e3bd82ffebce019c2bd2aef7981614fda2f99449a05b99af02b009b466f04fb9235058bb5063bad8999f5584af983e0bc880c0f9f5a0362577a6cbecc376b0a28ecf9eb20ca30a8d6dc4a3d1fa10aa812e73890226aaa0538142ef5e0391b909e4cbcaf552f350d5e6e4013875c8464bd609009ae93969a059948e852f11ddc67d11d76bd63443c59d9859924cd6ddab5b246c4c65cd7164a0f274b981006e9546f04986cb540e4fb232b6785f6291a7a9204212d4626a4fe8a0f13367a177f231efca2c09ea2b9ac8d4e81e7e34fae1702ba82543ba5e0fd3a2a06049cee1583bf1840ef3e549320ad05245f44c608f4de7745b17726350b77f8880',
    '0xf90211a01f286650dca667df07969c51f2e87deb55a5da04817768ef2e6d4bb569ead8b3a0ac91b5067e8dc7a6c4c8da7199ec63f430491a0d341d9f895b246f0bc156e524a001255c836afe4cb619ca8ab709f178a71ec460e786e1b5f2978889915ee5c242a09c7c13d13418fe6b7e50f0cb681ca51593072e96a4d53d656fe61a26fa763352a0b84bf44f2cf6fb177098b88f6521402205d2b360bef066d323ed0f4900d4fb2fa097719104f8e61e05b2c58e4c751af74db62abc4b40085125e2c8aec5c6bafd10a031929bb8a1356bb410d4d1abbfc66e402149a6a296674c180394173deea73089a0e7fef96390d3347d3f0f9ec50a2130ab8d78f2761965fa93f3f8f13c04c1e175a017f18fe87f0462c24e59e93dcdd9ecf79bf62e1855bf4c919b28e9000ec6ae1da08f03adcb00e1ce8f3b740a96ebcfe9479f02c23e60b8d4e1a139756e8897db31a09e621f639bcc7972f0c18135558fcf544ccd817d0bbcbc946d605ade08d9dd15a0c2662a6fbbcfdca81bfd8ad66119a2be1da6a18211373534cf750dd84c0f5cc0a085421954ec3e08560b211a8433d9fe1577e486cea4eeb5b9d4ec8bb458ed768da0e6b40a8e0df85841e0dc2299ac45f4c5c5b6cbd9f5ed5d85538d1fa9f3669bd0a019b937b0f8ddd3b29b3eaba3f32d2cad5961e7997139d4443260a9c3bb8be225a0f5a82fa94c96258eb4be53587c3380b7b4b76aa0261a27df2a1b22ed1959fe5380',
    '0xf871808080808080808080a0371cd8ef336cbe99e1cbf6a75284d5ab86aa809d09ce4086728f7dd5097fd78080a059479b31dc804e47d6104c2757d23eb2491fb91757e0124fe5b7982c39ab36d1a00f52b968a887beabac9aa6cc73a8cb35122dd17fe4186c0aea3d41ee901a2e6f80808080',
    '0xf8679e208f69419b49220ad2d32507fc84a498d64a85307b5e7c8e6d4bed192542b846f8440180a08a60e721b3bf246d6489ea3878b28581d2b30d5f7975ce30a005db88bfa5d7e3a054f6be0dcda96d7a9e03fa83473ab11fa501aea7dd25b1f41f35fa2c6545654f'
  ],
  balance: 0n,
  codeHash: '0x54f6be0dcda96d7a9e03fa83473ab11fa501aea7dd25b1f41f35fa2c6545654f',
  nonce: 1n,
  storageHash: '0x8a60e721b3bf246d6489ea3878b28581d2b30d5f7975ce30a005db88bfa5d7e3',
  storageProof: [
    {
      key: '0x0000000000000000000000000000000000000000000000000000000000000000',
      value: 414286707211789876254643222122350184116804480745n,
      proof: [Array]
    },
    {
      key: '0x0000000000000000000000000000000000000000000000000000000000000001',
      value: 0n,
      proof: [Array]
    },
    {
      key: '0x0000000000000000000000000000000000000000000000000000000000000002',
      value: 48n,
      proof: [Array]
    }
  ]
}
```

Note how in the storageProof.proof `[Array]` is printed here, the details can be obtained by directly printing `response.storageProof`. 

To test, you pick 1 of the storageProof elements, and copy the key and the proof elements into the storageProof. Also take the `storageHash`, this is the root (so the root is the same for all storageProofs of 1 contract). The value in the storageProof is what you're testing against.

Verifying a storageproof is done by entering key, proof elements and root. Then it returns the value for that key, which you then can compare to the expected value. 

## Convert to json string

In a Rust file, create an instance of a StorageProof, the type that is used in the Rust program for Bonsai as well
```
#[derive(Debug, Deserialize, Serialize)]
struct StorageProofInput {
  key: Vec<u8>,
  proof: Vec<Vec<u8>>,
  root: [u8; 32]
}

//...


let testInput2 = StorageProofInput {
    key: hex!("0000000000000000000000000000000000000000000000000000000000000002").to_vec(),
    proof: vec![
      hex!("f90211a02dd5554c64da86a68d33e5b5a3da6e4ad9b3c1b8efbd26229f73632a4660bbb7a01c8e6b3f78ebbc05e85b49b353ca300bcf110ba72a804758550a0cdd9af5e231a058133aec0bb2afa1d28303f61d9c8b682ac39577ab3297d5999dc019d97147c1a0b15c278e442f334481a3e35f6ef10d0ff5b662f882feb4e87036b335ac67c5afa04732d4096b796d8901083bc4f647c713ae6756ecb8993f7e58d92e4388b9ed7ea0843af62b2974ba2fe5003a36f27069f9a663654ae1fa2ad2749e9d8757ef4f03a0e9ed04967de6d3149f7b97bc3211d8f8eed899eff3bd29f54d573725f470218fa05689dc89aa5ae46c5d3dd4dfae945ecd3802aef23927891b1e90930388b03fb7a0886290335ba548a82098757132472f46581dad6e3d9c7b6d268389bf8a45cbdfa0f784d4e2ccb18a5253a766adacf59be1e72215673bb9310610a7ac7639b43fa5a0ff0c106d9b81b1e34b2678480a8cf698099ea5b0d3f3487ad13e50b280e808b0a074a8000c6227783c69e9971a4cbd992be617a736dba4bb2cfc3ea1ed73a0404ca0de8a0df34220cd0bd3aa8f06d3d096fbce6d8ed46fc769ca2c0a43dbc0f2fc97a071f7d5b3584d01037515900949508e6d326798cc9a80ba46cfa23874d8e2b9f7a0634d332a990574cf90a3d7a358f412abaf3fecbeb990b94993c1d7fb4f4d0293a04e374742e5575a8bdaf4ba80fce343f884c6b59ea6040dafc544da9d46fcda9180").to_vec(),
      hex!("f8f1a02a73a5b4e909bb2ed9520611744e3d20b441fcfffa523df18114fd3b33289d7780a00ddc966723ae79cb2062bd87d19340fe121eee60454ce607563a52669cd4fd0b80a0d01dd44c37b7bfdff81a44f967972fae34ac5451804c7b2494e258afbccd66a88080808080a01062555d66455b046ca8ca840d29d4d2d293132eb848317b4edef6ea0a505ecf80a00accc719c27a4944d31731d3c11e82d8406af432f6175dbb4e84e51908cdc01580a0b69cfe90bd7506dd91dab1e9aa664aa391d27914abbace3d98b542b44742f80aa0a4d0b16787f440098d7e7813b0fe1335e1fe73347d0ea4f3c3a71897665888f580").to_vec(),
      hex!("e2a0205787fa12a823e0f2b7631cc41b3ba8828b3321ca811111fa75cd3aa3bb5ace30").to_vec()
      ],
    root: hex!("8a60e721b3bf246d6489ea3878b28581d2b30d5f7975ce30a005db88bfa5d7e3")
  };
```

Then obtain the json string of this
```
use serde_json::to_string;
let str2 = to_string(&testInput2).unwrap();
```

This string can be used as the input for the Solidity contract.

## How the current tests work

1. Call function `verifyStorageProof` of the contract with a `test_id` and the string with testdata. The `test_id` is ultimately not necessary, it's just so we can retrieve a value for the moment.
2. Then call `retrieveResult` for that same `test_id`
3. Compare result to expected value accordin to the storageproof